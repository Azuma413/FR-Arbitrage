Metadata-Version: 2.4
Name: fr-arbitrage
Version: 0.2.0
Summary: Hyperliquid Yield Harvester — Delta-neutral FR arbitrage bot
Requires-Python: >=3.10
Description-Content-Type: text/markdown
Requires-Dist: hyperliquid-python-sdk>=0.9
Requires-Dist: aiohttp>=3.9
Requires-Dist: pydantic>=2.0
Requires-Dist: pydantic-settings>=2.0
Requires-Dist: structlog>=24.0
Requires-Dist: sqlalchemy>=2.0
Requires-Dist: aiosqlite>=0.19
Requires-Dist: wandb>=0.25.0

# プロジェクト仕様書（最終版）: Hyperliquid Yield Harvester

## 1. プロジェクト概要

Hyperliquid上のSpot（現物）とPerpetual（無期限先物）の間で、同一銘柄のデルタニュートラル・ポジションを構築し、Funding Rate（資金調達率）を半永久的に受け取り続ける「Cash & Carry（Basis Trading）」自動売買システム。

### コアコンセプト

* **戦略:** Spot買い + Perp売り（1:1ヘッジ）
* **収益源:** Perp市場のロング需要過多により発生するPositive Funding Rate。
* **主要件:** 低レイテンシ、原子性（Atomicity）の担保、厳格な資金管理。

## 2. 技術スタック & 環境

* **言語:** Python 3.10+ (Type Hinting, asyncio必須)
* **コアライブラリ:**
* `hyperliquid-python-sdk`: 公式SDK（署名・発注処理の中核）。
* `aiohttp`: REST APIの非同期リクエスト。
* `websockets`: Market Data（L2 Book, Trades）のリアルタイム受信。
* `sqlalchemy` + `aiosqlite`: 非同期DB処理による状態管理。
* `pydantic`: 環境変数・設定ファイルの型安全な管理。
* `structlog`: 構造化ログ（JSON形式）による可観測性の向上。


* **インフラ:**
* Docker Compose（Bot + SQLite volume）。
* VPS: AWS Tokyo/Singapore または Vultr Tokyo（Hyperliquidのエンドポイントに近いリージョン）。



## 3. システムアーキテクチャ

システムは `asyncio.gather` により並行稼働する4つの独立したサービスで構成される。

### 3.1. Market Data Streamer (Websocket)

* **役割:** 購読銘柄の最新価格（Best Bid/Ask）、Funding Rate、Open Interestをメモリ内の `MarketState` オブジェクトに常時反映する。
* **最適化:** REST APIポーリングは行わず、Websocketのみで価格を更新し、判断のレイテンシを最小化する。

### 3.2. Opportunity Scanner (Entry Logic)

* **スクリーニング基準:**
1. **Funding Rate:** 過去X時間の平均がプラス、かつ現在の予測値もプラスであること。
2. **Liquidity (OI):** Open Interest が $1M 以上（流動性枯渇によるスリッページ防止）。
3. **Spread Check:** `(Spot Ask - Perp Bid) / Spot Ask` が、24時間分のFunding収入を下回っていること（コスト回収期間の短縮）。


* **アクション:** 条件を満たし、かつポジションを持っていない銘柄があれば Execution Engine へシグナルを送る。

### 3.3. Execution Engine (Order Manager)

* **原子性（Atomicity）の模倣:** ブロックチェーン上のトランザクションではないため、完全なアトミック性は保証されない。以下のフローで擬似的に実現する。
1. **Spot Entry:** 指値（IOC: Immediate Or Cancel）で `Best Ask * (1 + Slippage Tolerance)` の価格で発注。
2. **Verify Spot:** 約定した数量 `executed_sz` を確認。0なら終了。
3. **Perp Entry:** Spotと同量を、指値（IOC）で `Best Bid * (1 - Slippage Tolerance)` の価格でショート発注。
4. **Error Handling (Rollback):**
* Perpが約定しなかった、または部分約定だった場合、**「Spotの過剰分」を即座に成行（またはAggressive Limit）で売却**し、デルタを0に戻す。
* *修正点:* 完全にポジションを閉じるのではなく、Perpの約定量に合わせてSpotを減らす「Netting」処理を優先し、無駄な手数料支払いを防ぐ。





### 3.4. Position Guardian (Risk & Rebalance)

* **役割:** 既存ポジションの監視とメンテナンス。
* **Exit条件（撤退）:**
* Funding Rateが一定期間（例: 3回連続）マイナスになった場合。
* Spreadが縮小し、利益確定のチャンス（Backwardation）が発生した場合。


* **Auto-Deleverage (Rebalance):**
* 価格上昇によりPerp側の含み損が拡大し、有効証拠金（USDC）が圧迫された場合、Spotを一部売却してUSDCに戻し、Perpの証拠金に充当する。
* **トリガー:** `Margin Usage > 80%` (または Leverage > 3x 等)。



## 4. 詳細ロジック仕様

### 4.1. メタデータ管理（重要）

Hyperliquidは銘柄ごとに小数点以下の桁数（Decimals）が厳密に決まっている。

* **Size Decimals (`sz_decimals`):** 発注数量の丸めに使用。
* **Price Decimals (`px_decimals`):** 指値価格の丸めに使用。
* **実装:** 起動時に `info.meta()` を一度だけ取得し、辞書形式で保持。発注関数内で必ず `round()` 処理を挟むラッパーを作成する。

### 4.2. 資金管理ロジック

Hyperliquidの仕様上、**Spot資産はPerpの証拠金（Cross Margin）としてカウントされない**（USDCのみが担保）。

* **初期配分 (例: 10,000 USDC):**
* Spot Allocation: 45% (4,500 USDC)
* Perp Collateral: 55% (5,500 USDC)
* *理由:* Perp側はFundingの支払いが（稀に）発生したり、価格上昇時の含み損に耐えるため、Spotより多くのUSDCを残す必要がある。


* **リバランス計算式:**
* もし `Perp Unrealized Loss` が拡大し、`Available Margin` が危険水域に入ったら：
* `Reduce Size = (Target Margin - Current Margin) / Current Price`
* 上記数量分のSpotを売り、Perpを買い戻す（ポジション縮小）。



---

## 5. データモデル (Persistence)

再起動時やクラッシュ時にポジションを見失わないよう、ローカルDBを「正」とする。

### 5.1. Database Schema (`positions` table)

| Column | Type | Description |
| --- | --- | --- |
| `symbol` | TEXT (PK) | 銘柄名 (例: HYPE, ETH) |
| `spot_sz` | REAL | 保有現物数量 |
| `perp_sz` | REAL | 保有ショート数量（負の値で管理するかフラグで管理するか統一） |
| `entry_price` | REAL | ポジション構築時の加重平均価格 |
| `accumulated_funding` | REAL | これまでに受け取ったFunding総額（集計用） |
| `state` | TEXT | `OPEN`, `REBALANCING`, `CLOSING_PENDING` |
| `updated_at` | DATETIME | 最終更新日時 |

---

## 6. コンフィグレーション (`config.py`)

Pydanticを使用し、バリデーション付きの設定管理を行う。

```python
from pydantic_settings import BaseSettings
from typing import List, Optional

class Settings(BaseSettings):
    # --- Network & Auth ---
    ENVIRONMENT: str = "MAINNET"  # or "TESTNET"
    PRIVATE_KEY: str  # 0x...
    account_address: str # wallet address derived from key

    # --- Strategy Parameters ---
    TARGET_COINS: List[str] = ["HYPE", "PURR", "SOL", "ETH"] # 監視対象
    BLACKLIST_COINS: List[str] = [] # 除外対象
    
    # Entry Filters
    MIN_FUNDING_RATE_HOURLY: float = 0.00002  # 0.002% per hour
    MAX_ENTRY_SPREAD: float = 0.001           # 0.1% spread limit
    MIN_DAILY_VOLUME: float = 1_000_000       # $1M volume

    # Execution Parameters
    SLIPPAGE_TOLERANCE: float = 0.002         # 0.2%
    MAX_RETRY_ATTEMPTS: int = 3
    
    # Position Sizing
    MAX_POSITION_USDC: float = 1000.0         # 1銘柄あたりの最大投入額
    LEVERAGE_BUFFER: float = 0.5              # Spot:Perp比率 (0.5 = 50:50配分からスタート)

    # --- System ---
    DB_URL: str = "sqlite+aiosqlite:///./yield_harvester.db"
    LOG_LEVEL: str = "INFO"

    class Config:
        env_file = ".env"

```

---

## 7. バックテスト & 検証フェーズ

### 7.1. HypeBacktester (Module)

* **データソース:** `/info` エンドポイントの `fundingHistory` および `candleSnapshot`。
* **評価指標:**
* **Net APR:** `Funding Income - (Entry Fee + Exit Fee + Slippage)`
* **Max Drawdown:** 資金調達率がマイナス化した際の最大損失幅。


* **目的:** 過去のデータに基づき、「スプレッド負け」せずに利益が出るまでの最短保有期間を算出する。

### 7.2. 運用ロードマップ

1. **Phase 1: Testnet Validation**
* Hyperliquid Testnetにて、`HYPE` などのテストトークンを用い、ロジック（特にEntry時のRollbackとRebalance）が正常に動作するか確認。
* 意図的に片側の注文を失敗させ、リカバリー処理が走るかテストする。


2. **Phase 2: Dry-Run (Mainnet)**
* 本番APIに接続するが、発注リクエストのみをモック（Mock）化。
* 「本来ならここでエントリーしていた」というログと、実際のスプレッド・板情報を照らし合わせ、条件が厳しすぎないか調整。


3. **Phase 3: Production (Canary Release)**
* 単一銘柄（例: HYPE）かつ少額（100 USDC）で稼働。
* 1週間稼働させ、エラーログと実際のFunding受取額を確認。


4. **Phase 4: Scale Out**
* 監視対象を複数銘柄に拡大。複利運用（利益が出たらポジションを積み増す）ロジックの有効化。
